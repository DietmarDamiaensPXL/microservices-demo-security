name: "Continuous Integration Pipeline"
on:
  workflow_dispatch:
  push:
    branches:
      - main
jobs:
  code-tests:
    runs-on: [self-hosted]
    steps:
    - uses: actions/checkout@v5
    - uses: actions/setup-dotnet@v5
      env:
        DOTNET_INSTALL_DIR: "./.dotnet"
      with:
        dotnet-version: '9.0'
    - uses: actions/setup-go@v6
      with:
        go-version: '1.25'
    - name: Go unit tests
      timeout-minutes: 10
      run: |
        for SERVICE in "shippingservice" "productcatalogservice"; do
          echo "testing $SERVICE..."
          pushd src/$SERVICE
          go test
          popd
        done
    - name: C# Unit Tests
      timeout-minutes: 10
      run: |
        dotnet test src/cartservice/
  security-tests:
    runs-on: [self-hosted]
    needs: code-tests
    steps:
    - uses: actions/checkout@v5
    - name: Trivy security scan
      id: trivy
      uses: aquasecurity/trivy-action@0.28.0
      with:
        scan-type: "fs"
        format: "table"
        output: "trivy-report.txt"
        severity: "HIGH,CRITICAL"
        ignore-unfixed: true
        exit-code: 1

    - name: Print Trivy report to logs
      if: always()
      run: |
        echo "============ Trivy Report (backend) ============"
        if [ -f trivy-report.txt ]; then
          cat trivy-report.txt
        else
          echo "No trivy-report.txt found"
        fi

    - name: Upload Trivy report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: trivy-report
        path: trivy-report.txt

  smoke-tests:
    runs-on: [self-hosted]
    needs: security-tests
    steps:
    - uses: actions/checkout@v5
    - name: Look for operating system
      id: detect_os
      run: |
        if [ "$RUNNER_OS" = "Windows" ]; then
          echo "os=windows" >> $GITHUB_OUTPUT
        else
          echo "os=linux" >> $GITHUB_OUTPUT
        fi
      shell: bash

    - name: Deploy based on OS
      run: |
        if [ "${{ steps.detect_os.outputs.os }}" = "windows" ]; then
          echo "Running on Windows"
          kind create cluster
          skaffold run
        else
          echo "Running on Linux"
          k3d cluster create mycluster --wait 5m
          kubectl apply -k ./kustomize
        fi
      shell: bash

    - name: Forwarding ports
      run: |
        kubectl port-forward deployment/frontend 8080:8080
        kubectl port-forward service/grafana 3000:3000
        kubectl port-forward service/prometheus 9090:9090
        kubectl port-forward service/mailhog 8025:8025
      shell: bash

    - name: Wait for pods
      run: |
        set -x
        kubectl config set-context --current --namespace=$NAMESPACE
        kubectl wait --for=condition=available --timeout=30s deployment/redis-cart
        kubectl wait --for=condition=available --timeout=30s deployment/adservice
        kubectl wait --for=condition=available --timeout=30s deployment/cartservice
        kubectl wait --for=condition=available --timeout=30s deployment/checkoutservice
        kubectl wait --for=condition=available --timeout=30s deployment/currencyservice
        kubectl wait --for=condition=available --timeout=30s deployment/emailservice
        kubectl wait --for=condition=available --timeout=30s deployment/frontend
        kubectl wait --for=condition=available --timeout=30s deployment/loadgenerator
        kubectl wait --for=condition=available --timeout=30s deployment/paymentservice
        kubectl wait --for=condition=available --timeout=30s deployment/productcatalogservice
        kubectl wait --for=condition=available --timeout=30s deployment/recommendationservice
        kubectl wait --for=condition=available --timeout=30s deployment/shippingservice

    - name: Smoke Test
      run: |
        set -x
        # start loadgenerator pod
        kubectl delete pod -l app=loadgenerator
        # wait for requests to come in
        REQUEST_COUNT="0"
        while [[ "$REQUEST_COUNT"  -lt "50"  ]]; do
            sleep 5
            REQUEST_COUNT=$(kubectl logs -l app=loadgenerator | grep Aggregated | awk '{print $2}')
        done
        # ensure there are no errors hitting endpoints
        ERROR_COUNT=$(kubectl logs -l app=loadgenerator | grep Aggregated | awk '{print $3}' | sed "s/[(][^)]*[)]//g")

        # Generate smoke test report
        echo "============ Smoke Test Report ============" > smoke-test-report.txt
        echo "Date: $(date)" >> smoke-test-report.txt
        echo "Total Requests: $REQUEST_COUNT" >> smoke-test-report.txt
        echo "Total Errors: $ERROR_COUNT" >> smoke-test-report.txt
        echo "" >> smoke-test-report.txt
        echo "Test Result: " >> smoke-test-report.txt
        if [[ "$ERROR_COUNT" -gt "0" ]]; then
          echo "FAILED - Errors detected in loadgenerator" >> smoke-test-report.txt
          cat smoke-test-report.txt
          exit 1
        else
          echo "PASSED - No errors detected" >> smoke-test-report.txt
          cat smoke-test-report.txt
        fi

    - name: Upload Smoke Test report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: smoke-test-report
        path: smoke-test-report.txt

    - name: Cleanup cluster
      if: always()
      run: |
        if [ "${{ steps.detect_os.outputs.os }}" = "linux" ]; then
          echo "Cleaning up k3d cluster"
          k3d cluster delete mycluster
        else
          echo "Cleaning up Skaffold deployment"
          kind delete cluster
        fi
      shell: bash
